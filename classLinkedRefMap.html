<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>silicondb: LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">silicondb
   </div>
   <div id="projectbrief">A concurrent key-value store, column oriented database and more.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classLinkedRefMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container class representing a vector of objects with keys.  
 <a href="classLinkedRefMap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linkedmap_8h_source.html">linkedmap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9db9596845180652ad8b36774d6d9b30"><td class="memItemLeft" align="right" valign="top"><a id="a9db9596845180652ad8b36774d6d9b30"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b> = T *</td></tr>
<tr class="separator:a9db9596845180652ad8b36774d6d9b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memItemLeft" align="right" valign="top"><a id="ae57b9ddb3cac6283df8b9747dff2e1da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vec</b> = std::vector&lt; Ptr &gt;</td></tr>
<tr class="separator:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c1420984bc5d41ef945689343be5c"><td class="memItemLeft" align="right" valign="top"><a id="aee7c1420984bc5d41ef945689343be5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = typename Vec::iterator</td></tr>
<tr class="separator:aee7c1420984bc5d41ef945689343be5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memItemLeft" align="right" valign="top"><a id="ae9d600d6dc898d3efd063381f60eaaf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = typename Vec::const_iterator</td></tr>
<tr class="separator:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memItemLeft" align="right" valign="top"><a id="a7c63027ad3bccd9ba3a87b2818ecf12a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = typename Vec::reverse_iterator</td></tr>
<tr class="separator:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memItemLeft" align="right" valign="top"><a id="a5d04d68baaeb769cfe0e3cfa9873e40f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = typename Vec::const_reverse_iterator</td></tr>
<tr class="separator:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb98d71aa057bea38e63d6bfd792cf54"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#acb98d71aa057bea38e63d6bfd792cf54">find</a> (const char *key_) const</td></tr>
<tr class="separator:acb98d71aa057bea38e63d6bfd792cf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27b74a169a3ea0b7ff7b3924d5ef60a"><td class="memItemLeft" align="right" valign="top"><a id="af27b74a169a3ea0b7ff7b3924d5ef60a"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#af27b74a169a3ea0b7ff7b3924d5ef60a">find</a> (const char *key)</td></tr>
<tr class="memdesc:af27b74a169a3ea0b7ff7b3924d5ef60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const <br /></td></tr>
<tr class="separator:af27b74a169a3ea0b7ff7b3924d5ef60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273fe87b60116a378346a858e11e4b6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a273fe87b60116a378346a858e11e4b6e">add</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a273fe87b60116a378346a858e11e4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821db7bc14f1498938bd5314502f3655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#a821db7bc14f1498938bd5314502f3655">prepend</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a821db7bc14f1498938bd5314502f3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd71d962feafbb7f600a704f7dcdee5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedRefMap.html#acfd71d962feafbb7f600a704f7dcdee5">del</a> (const char *key_)</td></tr>
<tr class="separator:acfd71d962feafbb7f600a704f7dcdee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071df73ec22c01a9443627507f23322"><td class="memItemLeft" align="right" valign="top"><a id="aa071df73ec22c01a9443627507f23322"></a>
Ptr &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t pos)</td></tr>
<tr class="separator:aa071df73ec22c01a9443627507f23322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53176b1c8a9abb7a103108f720372c21"><td class="memItemLeft" align="right" valign="top"><a id="a53176b1c8a9abb7a103108f720372c21"></a>
const Ptr &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t pos) const</td></tr>
<tr class="separator:a53176b1c8a9abb7a103108f720372c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memItemLeft" align="right" valign="top"><a id="ac2f30ce85fd85bfb75bcb56bd10fe9a4"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d843d470df85d608d8d47b2a56c5e80"><td class="memItemLeft" align="right" valign="top"><a id="a7d843d470df85d608d8d47b2a56c5e80"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a7d843d470df85d608d8d47b2a56c5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3307eb17ea829836140639cb52115"><td class="memItemLeft" align="right" valign="top"><a id="a77a3307eb17ea829836140639cb52115"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a77a3307eb17ea829836140639cb52115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memItemLeft" align="right" valign="top"><a id="a6fed959ab40da898bbebfdb3c8653b2c"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memItemLeft" align="right" valign="top"><a id="ac971d2e3cc8e2651f5648b6946b25bd7"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a306a67c71e29179b309647309d6e96"><td class="memItemLeft" align="right" valign="top"><a id="a2a306a67c71e29179b309647309d6e96"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:a2a306a67c71e29179b309647309d6e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memItemLeft" align="right" valign="top"><a id="a2d088d23b0ce73cf2ed3b8cfc2fbe89d"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="separator:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memItemLeft" align="right" valign="top"><a id="ab67fb1418120d42cf91a2a033a6b16ad"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="separator:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eea714e29d412612981ac2a8bcab40"><td class="memItemLeft" align="right" valign="top"><a id="ad4eea714e29d412612981ac2a8bcab40"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:ad4eea714e29d412612981ac2a8bcab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memItemLeft" align="right" valign="top"><a id="a5fe0b41a59bcf683e2ade44911a3fe1d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67fa2110f306614b020782b88c28c83"><td class="memItemLeft" align="right" valign="top"><a id="ad67fa2110f306614b020782b88c28c83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ad67fa2110f306614b020782b88c28c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Hash = std::hash&lt;std::string&gt;, class KeyEqual = std::equal_to&lt;std::string&gt;, class Map = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt;<br />
class LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;</h3>

<p>Container class representing a vector of objects with keys. </p>
<p>Objects can be efficiently be looked up given the key. Objects are <em>not</em> owned by the container, the container will only hold references. When adding objects the order of addition is kept, and used while iterating. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a273fe87b60116a378346a858e11e4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273fe87b60116a378346a858e11e4b6e">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>

</div>
</div>
<a id="acfd71d962feafbb7f600a704f7dcdee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd71d962feafbb7f600a704f7dcdee5">&#9670;&nbsp;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes an object from the container and deletes it. Returns true if the object was deleted or false it is was not found. </p>

</div>
</div>
<a id="acb98d71aa057bea38e63d6bfd792cf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb98d71aa057bea38e63d6bfd792cf54">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

</div>
</div>
<a id="a821db7bc14f1498938bd5314502f3655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821db7bc14f1498938bd5314502f3655">&#9670;&nbsp;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLinkedRefMap.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepends an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/silicondb/silicondb/doxygen-1.9.1/src/<a class="el" href="linkedmap_8h_source.html">linkedmap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
